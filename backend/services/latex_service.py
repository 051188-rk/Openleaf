import os
import subprocess
import uuid
import re
import base64
import io
from pathlib import Path
from PIL import Image, ImageDraw, ImageFont
from pdf2image import convert_from_path
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.enums import TA_LEFT, TA_CENTER

TEMP_DIR = Path("temp_latex")
TEMP_DIR.mkdir(exist_ok=True)

def extract_text_from_latex(latex_content: str) -> dict:
    """Extract text content from LaTeX for simple PDF rendering"""
    # Remove LaTeX commands and extract content
    text = latex_content
    
    # Extract name (usually after \name or in first section)
    name_match = re.search(r'\\name\{([^}]+)\}', text)
    name = name_match.group(1) if name_match else "Resume"
    
    # Extract sections
    sections = []
    
    # Find section headers and content
    section_pattern = r'\\section\{([^}]+)\}(.*?)(?=\\section|\\end\{document\}|$)'
    for match in re.finditer(section_pattern, text, re.DOTALL):
        section_title = match.group(1)
        section_content = match.group(2)
        
        # Clean up LaTeX commands
        content_clean = re.sub(r'\\[a-zA-Z]+(\[[^\]]*\])?(\{[^}]*\})?', '', section_content)
        content_clean = content_clean.replace('\\\\', '\n').replace('&', ' ')
        content_clean = ' '.join(content_clean.split())  # Clean whitespace
        
        if content_clean.strip():
            sections.append({'title': section_title, 'content': content_clean})
    
    return {'name': name, 'sections': sections}

def create_simple_pdf(latex_content: str) -> str:
    """Create a simple PDF from LaTeX content using reportlab"""
    session_id = str(uuid.uuid4())
    pdf_file = TEMP_DIR / f"{session_id}.pdf"
    
    # Extract content
    parsed = extract_text_from_latex(latex_content)
    
    # Create PDF
    doc = SimpleDocTemplate(str(pdf_file), pagesize=letter,
                           topMargin=0.75*inch, bottomMargin=0.75*inch,
                           leftMargin=0.75*inch, rightMargin=0.75*inch)
    
    styles = getSampleStyleSheet()
    
    # Custom styles
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        textColor='black',
        spaceAfter=12,
        alignment=TA_CENTER,
        fontName='Helvetica-Bold'
    )
    
    section_style = ParagraphStyle(
        'SectionHeader',
        parent=styles['Heading2'],
        fontSize=14,
        textColor='black',
        spaceAfter=6,
        spaceBefore=12,
        fontName='Helvetica-Bold',
        borderWidth=0,
        borderPadding=0,
        borderColor='black',
        borderRadius=0,
    )
    
    body_style = ParagraphStyle(
        'CustomBody',
        parent=styles['BodyText'],
        fontSize=10,
        textColor='black',
        spaceAfter=6,
        alignment=TA_LEFT,
        fontName='Helvetica'
    )
    
    # Build document
    story = []
    
    # Add name/title
    story.append(Paragraph(parsed['name'], title_style))
    story.append(Spacer(1, 0.2*inch))
    
    # Add sections
    for section in parsed['sections']:
        story.append(Paragraph(f"<b>{section['title']}</b>", section_style))
        story.append(Paragraph(section['content'], body_style))
        story.append(Spacer(1, 0.1*inch))
    
    # Add footer
    story.append(Spacer(1, 0.3*inch))
    footer_style = ParagraphStyle('Footer', parent=styles['Normal'], fontSize=8, 
                                  textColor='gray', alignment=TA_CENTER)
    story.append(Paragraph("Generated by res-gen | AI Resume Generator", footer_style))
    
    doc.build(story)
    return str(pdf_file)

def compile_latex_to_pdf(latex_content: str) -> str:
    """
    Compiles LaTeX content to PDF.
    Falls back to simple PDF generation if pdflatex is not available.
    """
    # Try pdflatex first
    session_id = str(uuid.uuid4())
    tex_file = TEMP_DIR / f"{session_id}.tex"
    pdf_file = TEMP_DIR / f"{session_id}.pdf"
    
    # Check if pdflatex exists
    try:
        subprocess.run(["pdflatex", "--version"], 
                      stdout=subprocess.PIPE, 
                      stderr=subprocess.PIPE,
                      timeout=5)
        has_pdflatex = True
    except (FileNotFoundError, subprocess.TimeoutExpired):
        has_pdflatex = False
    
    if has_pdflatex:
        # Write latex content to file
        with open(tex_file, "w", encoding="utf-8") as f:
            f.write(latex_content)
            
        try:
            process = subprocess.run(
                ["pdflatex", "-interaction=nonstopmode", "-output-directory", str(TEMP_DIR), str(tex_file)],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=10
            )
            
            if process.returncode == 0 and pdf_file.exists():
                return str(pdf_file)
        except Exception as e:
            print(f"pdflatex failed: {e}, falling back to simple PDF")
    
    # Fallback to simple PDF generation
    print("Using simple PDF generation (pdflatex not available)")
    return create_simple_pdf(latex_content)

def create_error_image(error_message: str) -> str:
    """Create an image displaying an error message"""
    # Create a white image with error text
    img = Image.new('RGB', (800, 1000), color='white')
    draw = ImageDraw.Draw(img)
    
    # Try to use a font, fallback to default if not available
    try:
        font_title = ImageFont.truetype("arial.ttf", 24)
        font_body = ImageFont.truetype("arial.ttf", 14)
    except:
        font_title = ImageFont.load_default()
        font_body = ImageFont.load_default()
    
    # Draw error title
    draw.text((50, 50), "LaTeX Compilation Error", fill='red', font=font_title)
    
    # Draw error message (word wrap)
    y_offset = 100
    max_width = 700
    words = error_message.split()
    lines = []
    current_line = []
    
    for word in words:
        test_line = ' '.join(current_line + [word])
        bbox = draw.textbbox((0, 0), test_line, font=font_body)
        if bbox[2] - bbox[0] <= max_width:
            current_line.append(word)
        else:
            if current_line:
                lines.append(' '.join(current_line))
                current_line = [word]
            else:
                lines.append(word)
    if current_line:
        lines.append(' '.join(current_line))
    
    for line in lines[:30]:  # Max 30 lines
        draw.text((50, y_offset), line, fill='black', font=font_body)
        y_offset += 25
    
    # Convert to base64
    buffered = io.BytesIO()
    img.save(buffered, format="PNG")
    img_str = base64.b64encode(buffered.getvalue()).decode()
    return f"data:image/png;base64,{img_str}"

def compile_latex_to_image(latex_content: str) -> str:
    """
    Compiles LaTeX content to a base64-encoded PNG image for preview.
    Returns base64 data URL string.
    """
    try:
        # First compile to PDF
        pdf_path = compile_latex_to_pdf(latex_content)
        
        if not pdf_path or not os.path.exists(pdf_path):
            return create_error_image("PDF generation failed")
        
        # Convert PDF first page to image
        try:
            images = convert_from_path(pdf_path, first_page=1, last_page=1, dpi=150)
            if not images:
                return create_error_image("PDF conversion to image failed")
            
            # Convert to base64
            buffered = io.BytesIO()
            images[0].save(buffered, format="PNG")
            img_str = base64.b64encode(buffered.getvalue()).decode()
            
            return f"data:image/png;base64,{img_str}"
            
        except Exception as e:
            return create_error_image(f"Image conversion error: {str(e)}")
            
    except Exception as e:
        return create_error_image(f"Compilation error: {str(e)}")

